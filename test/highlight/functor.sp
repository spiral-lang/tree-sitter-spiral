


adas{};
// ^ local.reference
3xdsdsad;
// ^ local.reference
(sdasd(): sdsds()-> 3 );
//         ^ local.reference
the_ref::asda;
// ^ local.reference
(...dasdas);
//   ^ local.reference
x..x;
// ^ local.reference
  xsds...x;
// ^ local.reference
z + y;
//  ^ local.reference
    zzzz + y + r;
//  ^ local.reference
c | x;
//  ^ local.reference
   cool | x;
//  ^ local.reference
x == cxcx;
	xdds == c;
	sdasx.cxzcx.czxc;
//   ^ local.reference
!dasd;
// ^ local.reference
dasd?;
// ^ local.reference
5...5 + 5;
//  ^ natural_number

-5...5 + 5;
//     ^ operator

fn (xdd, y=5){
//  ^ local.definition
}
fn (xdd, yfff=5){
}
//curry
const x = (x, x=5)=>(y)=>(z)=>(w)=> x + y + z + w;
//    ^ local.definition
//or is not, == -> in == &&

x = while true { return 5; {7, 5}}
//    ^ keyword

fn (){} | { 3 + 5 }
//      ^ keyword.operator

5 + {} -3 | {-, ==, +, on};
!3;
3 | {};
3;
3 == 5;
x and d or 5;

!!dd{let dd, ff};
{x=30};
!_.c;
{x:154}
{x}
{c, c, m.k.j};
5;
(k: (+, _.root, !_.children), node:Node);

(path: (_.root, _.children*), node:Node);

3;
4545;
0b101011;
//  ^ natural_number

0xAe;
0o44;
454.545'e+5451;
454'e+5451;
//  ^ number_suffix

{k, y, c}
//functor without argument
mod 'self::asd{}
//  ^ symbol

'self:asd @  mod 'self::asd{}
//     ^ local.definition
//           ^ hof

mod 'self::asd{x=30}
mod 'self::asd(){x= 30;}
let ::x = 50;
const ::x = 50;
{let @'self::asa asa: 30}
{let @'self:asa asa: 30}
{let @asa asa: 30}
cas(x, y);

x = 30;
x = rb'{}`sasdasd  {#sds  lkl + kl*20}`;
x = rb'()`sasdasd  (#sds  lkl + kl*2)`;
x = rb'«»`sasdasd  «#sds  lkl + kl*20»`;
x = rb'‹›`sasdasd  ‹#sds  lkl + kl*20›`;
x = r`sasdasd  sasdasdsasdasdsasdasdsasdasdsasdasd`;
x = rb`sasdasd  sasdasdsasdasdsasdasdsasdasdsasdasd`;
x = `sadasdaassssssssssssssssdasd`;
#sadasd;

errmnmnmn::graph;

#delegate yield #fre 30;
//^ decorator

#delegate return #fre 30;
if x is Some(Result::Error{let e}) {

}


while y {
  x;
   <element>
   	<ul>
    <li s=125>sasasasdasdasd</li>
    </ul>
   </element>;
}
for x of y {
  x;
   <element>
   	<ul>
    <li s=125>sasasasdasdasd</li>
    </ul>
   </element>;
}

for (path: (_.root, _.children*), node:Node) of x {4;5 }

for x of y {x}

for x of (x, x) {
	d;
}
for x of s(x, x) {
	d;
}
for x of ({x, x}=>y) {
	d;
}
x -> y;

x += 1;
y = (5389878.45431'Gigabytes/s^2);

//named functo
//named functor
//^ comment
functor graph(){
	'self;
	return graph(x):u32{x};
}
x on {
}
sd():u32{};
graph(x)=>u32;
[x]=>u32;
{x}=>u32;
x=>u32;
//^ delimiter.special

x=> x >  10 then 50
	   | x > 5 then 30
       | 59;

aasdas is not 4 | sdasds is 25;
sads -> sdasd  == sdasd -> asdasd;
mm -> as | y -> dasd;
mm == as | y != dasd & y > 5;
3 + 5 | 4 + 8 | 5 * 5;
3 & 5 | 4 & 8 | 5 & 5;
3 ∘ 5 | 4 ∘ 8 | 5 & 5 ∘ 6;
//^ keyword.operator

3 and 5 | 4 and 8 | 5 and 5;
3 or 5 | 4 or 8 | 5 or 5 & 30;
3 + 5 & 4 * 8 | 4 or 8 | 5 & 45 or 5 + 32?;
!5 | !N;
5 | 32?;
5 | !N;
5 + 32?;
!5 + 32?;
!5 + 32?;
!5 + !N;
!!!!5 + !N???;


sadsds::sdasdasd::<s=50, k, dssdg::sada=55, 'observer={c:45, y:35}, dadas::asdas={x; y},  'asad=ss::sasd::<>,'asad=ss::sasd::<x=5>, dasdasd::sdasd=[1,2,3,5]>;
sadsds::sdasdasd::<asd::sdsd=5445.54545'e+87>;
sadsds::sdasdasd::<asd::sdsd=`sdsadasd`>;
sadsds::sdasdasd::<asd::sdsd={2 | 5}>;
sadsds::sdasdasd::<'asd={2 + 5}>;
#sdasd sadsds::sdasdasd::<asd::sdsd=`sdsadasd`>;

let x = some::sadasd::asd;
let wqqwewewq = sad;
let w = lasas.(-> | is | + );
let y = 90.ll;


use sdasd::asdsa::{dsa, 'sad};
//^ keyword

#_ use tree;
#!ambient? #sadasdasd? use sdasd::asdsa::{dsa, 'sad}
#(ambient | rule) #(sdsd asdas{ddfddf{};})? #dasdasd{} use sdasd::asdsa::{dsa, 'sad};

x;

<-->
# abcd
dasdasdasd
asdasd

```sp


```
</-->
//^ document


<element>
	<ul>
   <li s=125>sasasasdasdasd</li>
   </ul>
</element>


//named functor
functor graph(){
//^ hof

	'self;
	return graph(x):u32{x};
}

//named functor
functor graph(){
//^ hof

	'self;
	graph(x)->u32(x);
}


//without name
fn (){
	let y = 5;
}

let x:String = String{`adasdasd`} + string();
let x = theory;
let x:mod = mod{};
let x = graph;
mod::asdas::some;
mod::asdas;
some::asdasd;
none;
sads::none;

#hff aaa::export 'self::sdasd (){
	5;
    4;
    50
}
#dasd fn 'self::asas (){


}

#!asdasd?
#theory mod  'self::asas{


}



{
  let @ name = `John`,
  age=30,
  cars= {
  //^ key

    car1: `Ford`,
    car2: `BMW`,
    car3: `Fiat`,
    fn: 30,

  }
};

<asa k=30/>
//   ^ key


{
    `_id`: `5e1b453aef5a8175d3d8c61e`,
//          ^ string

    `index`: 4,
//    ^ string

    `guid`: `98f1bd0f-bab3-4aec-bb66-51ed273c2a00`,
    `isActive`: true,
    `balance`: 1_578.25$,
    `picture`: `http://placehold.it/32x32`,
    `age`: 37,
    `eyeColor`: `blue`,
    `name`: `Lindsey Alford`,
    `gender`: `male`,
    `company`: `HOTCAKES`,
    `email`: `lindseyalford@hotcakes.com`,
    `phone`: `+1 (983) 544-3583`,
    `address`: `347 Fiske Place, Ada, Oklahoma, 4748`,
    `about`: `Tempor {yy + qui + 5.354 * 6 == 33} velit incididunt do occaecat sint quis fugiat. Qui ex fugiat amet qui eu culpa pariatur reprehenderit cupidatat cupidatat est eiusmod esse. Sunt officia cillum Lorem minim irure. Enim aute anim enim sit. Ad elit est ad id velit eu proident. Cillum occaecat ea nisi eiusmod ad.\r\n`,
    `registered`: `2016-02-13T01:37:30 +05:00`,
    `latitude`: 67.314338,
    `longitude`: 118.98787,
    `tags`: [
      `in`,
      `dolor`,
      `proident`,
      `sint`,
      `est`,
      `sit`,
      `dolor`
    ],
    `friends`: [
      {
        `id`: 0,
        `name`: `Tonia Brennan`
      },
      {
        `id`: 1,
        `name`: `Jennifer Gibson`
      },
      {
        `id`: 2,
        `name`: `Berger Gonzales`
      }
    ],
    `lklk`.sdasd::sdasd  = 40,
    `greeting`: `Hello, Lindsey Alford! You have 8 unread messages.`,
    `favoriteFruit`: `banana`
 };

{ let@ jj asdas: 30,
field{y=50},
field{y=50},
field{y=50},
field{y=50},
field{string=50},
}
let y = str;
//sadasddfsdfd sadasd

/*
asdasdasdasds
   */
//^ comment


let x = `asd\u{454}dasd {ds = s + 5}`;
let hjhkhjhdf_adasdasdjx = '\u{125}';
let y = 'ss * 5 == 5;

if C == #nat number + s{} +  5 {
	x;
}
while C == #nat number {
	x;
}

for x of  C == #nat number + sd(x, y) + 5 {
	x;
}



struct Action::<C, T>
//^ hof

	where C == #nat + {} + 3
    where C == #nat nat
	where C == #nat number + (d{k:4})
	where C == #nat number
	where C == #nat number
{
  x: int,
  y: T
}


for (@index: number, @path: (_.root, _.children*), @node:Node) of graph.bfs.enumerate {



}

let x = num;
num::ss;
g.+(50);
num + num;
num + {};
num | num;
num == num;
num == {};
num | {};
num | +;
if num == 5 {
}
if num | 5 {
}
if 5 | num {
}
if 5 == num {
}
if num + num {
}

graph sdas{
	Edge{},
};

graph sdas (){
	Edge{};
};

graph()->5;
a.d;
a => c;
(3 | ==, +);
!graph;
graph?;
return graph;
x > 5;
z < 65;
//^ keyword.operator
  <el />
//^ delimiter

g.+(50);
//^ operator
5btc + 3$;
//      ^ currency
